<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sloth's Leaf Sanctuary - Realistic Edition</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            background: #0b1e2e;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #gameCanvas { display: block; }
        #ui {
            position: absolute; top: 10px; left: 10px; color: #e8f5e9;
            font-size: 28px; font-weight: bold; text-shadow: 0 0 10px rgba(0,0,0,0.8);
            z-index: 10; background: rgba(0,0,0,0.4); padding: 15px 25px; border-radius: 15px;
            border: 2px solid rgba(100,150,100,0.6);
        }
        #stats {
            position: absolute; top: 80px; left: 10px; color: #e8f5e9;
            font-size: 16px; text-shadow: 0 0 10px rgba(0,0,0,0.8);
            z-index: 10; background: rgba(0,0,0,0.4); padding: 10px 20px; border-radius: 10px;
            border: 2px solid rgba(100,150,100,0.4);
        }
        #instructions {
            position: absolute; top: 10px; right: 10px; background: rgba(0,0,0,0.5);
            color: #e8f5e9; padding: 15px; border-radius: 10px; font-size: 15px; max-width: 280px;
            border-left: 4px solid #8BC34A;
        }
        #controls { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 10; }
        button {
            margin: 0 15px; padding: 14px 28px; font-size: 18px; background: #2E7D32;
            color: white; border: none; border-radius: 12px; cursor: pointer; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4); transition: all 0.3s;
        }
        button:hover:not(:disabled) { background: #388E3C; transform: translateY(-3px); box-shadow: 0 6px 20px rgba(0,0,0,0.5); }
        button:active:not(:disabled) { transform: translateY(-1px); }
        button:disabled { background: #666; cursor: not-allowed; transform: none; opacity: 0.5; }
        #modal {
            display: none; position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%); background: rgba(30,50,30,0.98);
            padding: 40px; border-radius: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            z-index: 100; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;
            text-align: center; color: #e8f5e9; border: 3px solid #8BC34A;
        }
        #modalTitle {
            font-size: 24px;
            margin-bottom: 15px;
        }
        #modalText {
            font-size: 18px;
            line-height: 1.4;
            margin: 20px 0;
        }
        .answer-btn {
            display: block; width: 100%; margin: 12px 0; padding: 16px;
            background: #1B5E20; color: white; border: none; border-radius: 10px;
            cursor: pointer; font-size: 18px; transition: all 0.3s;
        }
        .answer-btn:hover { background: #2E7D32; transform: scale(1.03); }
        
        /* Mobile control button styles */
        .mobile-btn-active {
            background: rgba(76,175,80,1) !important;
            box-shadow: inset 0 3px 8px rgba(0,0,0,0.5) !important;
            border-color: rgba(139,195,74,1) !important;
        }
        
        #mobileControls {
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            pointer-events: auto;
        }
        
        #mobileControls button {
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: all 0.1s ease;
            pointer-events: auto;
        }
        
        #mobileControls {
            transform: scale(0.6);
            transform-origin: bottom left;
        }
        
        /* Joystick styles */
        #joystickContainer {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 120px;
            height: 120px;
            z-index: 20;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        #joystickBase {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(46,125,50,0.4);
            border: 3px solid rgba(255,255,255,0.4);
            border-radius: 50%;
            box-shadow: 0 3px 10px rgba(0,0,0,0.3);
        }
        
        #joystickStick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(76,175,80,0.9);
            border: 3px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.4);
            left: 35px;
            top: 35px;
            transition: none;
        }
        
        body.mobile-mode #joystickContainer {
            transform: scale(0.8);
            transform-origin: bottom right;
        }
        
        /* Start screen */
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a4d1a 0%, #0b1e2e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #e8f5e9;
        }
        
        #startScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(139,195,74,0.8);
        }
        
        #startScreen p {
            font-size: 20px;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
            line-height: 1.6;
        }
        
        .mode-btn {
            margin: 15px;
            padding: 20px 50px;
            font-size: 24px;
            background: #2E7D32;
            color: white;
            border: 3px solid #8BC34A;
            border-radius: 15px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            transition: all 0.3s;
        }
        
        .mode-btn:hover {
            background: #388E3C;
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 8px 25px rgba(139,195,74,0.6);
        }
        
        .mode-btn:active {
            transform: translateY(-2px);
        }
        
        /* Mobile landscape mode */
        body.mobile-mode {
            transform: rotate(90deg);
            transform-origin: center center;
            width: 100vh;
            height: 100vw;
            overflow: hidden;
            position: fixed;
            top: 50%;
            left: 50%;
            margin-top: -50vw;
            margin-left: -50vh;
        }
        
        body.mobile-mode #gameCanvas {
            width: 100vh;
            height: 100vw;
        }
        
        /* Smaller UI elements for mobile mode */
        body.mobile-mode #ui {
            font-size: 16px;
            padding: 6px 12px;
            top: 5px;
            left: 5px;
        }
        
        body.mobile-mode #stats {
            font-size: 11px;
            padding: 5px 10px;
            top: 45px;
            left: 5px;
        }
        
        body.mobile-mode #instructions {
            font-size: 9px;
            padding: 6px;
            top: 5px;
            right: 5px;
            max-width: 100px;
            line-height: 1.2;
        }
        
        body.mobile-mode #controls button {
            padding: 8px 16px;
            font-size: 14px;
            margin: 0 8px;
        }
        
        body.mobile-mode #riddleBtn {
            padding: 8px 16px;
            font-size: 14px;
        }
        
        /* Mobile modal adjustments */
        body.mobile-mode #modal {
            padding: 15px;
            width: 80%;
            max-width: 500px;
            max-height: 85vh;
            font-size: 13px;
        }
        
        body.mobile-mode #modalTitle {
            font-size: 16px;
            margin-bottom: 10px;
        }
        
        body.mobile-mode #modalText {
            font-size: 13px;
            line-height: 1.3;
            margin: 12px 0;
        }
        
        body.mobile-mode .answer-btn {
            padding: 10px;
            font-size: 12px;
            margin: 6px 0;
        }
        
        body.mobile-mode #closeModal {
            padding: 8px 16px;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<div id="startScreen">
    <h1>ü¶• Sloth's Leaf Sanctuary üçÉ</h1>
    <p>Welcome to the mystical forest! Choose your control mode to begin your journey.</p>
    <div>
        <button class="mode-btn" onclick="startGame('desktop')">üñ•Ô∏è Desktop Mode</button>
        <button class="mode-btn" onclick="startGame('mobile')">üì± Mobile Mode</button>
    </div>
</div>

<div id="ui">üçÉ Leaves: <span id="leafCount">0.00</span></div>

<div id="stats">
    üìç Position: <span id="posDisplay">0, 0</span><br>
    üéØ Distance to Sloth: <span id="distDisplay">0</span>m
</div>

    <div id="instructions">
    <strong>Sloth's Leaf Sanctuary</strong><br><br>
    Controls:<br>
    W ‚Äî Forward<br>
    S ‚Äî Backward<br>
    A ‚Äî Left<br>
    D ‚Äî Right<br>
    Mouse ‚Äî Look around<br><br>
    Collect floating leaves. Each leaf = 0.5üçÉ. Get 13.5+ to talk to the sloth!
</div>

<div id="mobileControls" style="display: none; position: fixed; bottom: 10px; left: 10px; z-index: 20;">
    <div style="position: relative; width: 180px; height: 180px;">
        <button id="btnUp" style="position: absolute; left: 60px; top: 0; width: 60px; height: 60px; background: rgba(46,125,50,0.8); color: white; border: 2px solid rgba(255,255,255,0.6); font-size: 24px; box-shadow: 0 3px 8px rgba(0,0,0,0.4); font-weight: bold; border-radius: 8px;">‚ñ≤</button>
        <button id="btnDown" style="position: absolute; left: 60px; bottom: 0; width: 60px; height: 60px; background: rgba(46,125,50,0.8); color: white; border: 2px solid rgba(255,255,255,0.6); font-size: 24px; box-shadow: 0 3px 8px rgba(0,0,0,0.4); font-weight: bold; border-radius: 8px;">‚ñº</button>
        <button id="btnLeft" style="position: absolute; left: 0; top: 60px; width: 60px; height: 60px; background: rgba(46,125,50,0.8); color: white; border: 2px solid rgba(255,255,255,0.6); font-size: 24px; box-shadow: 0 3px 8px rgba(0,0,0,0.4); font-weight: bold; border-radius: 8px;">‚óÑ</button>
        <button id="btnRight" style="position: absolute; left: 120px; top: 60px; width: 60px; height: 60px; background: rgba(46,125,50,0.8); color: white; border: 2px solid rgba(255,255,255,0.6); font-size: 24px; box-shadow: 0 3px 8px rgba(0,0,0,0.4); font-weight: bold; border-radius: 8px;">‚ñ∫</button>
    </div>
</div>

<div id="joystickContainer" style="display: none;">
    <div id="joystickBase"></div>
    <div id="joystickStick"></div>
</div>

<canvas id="gameCanvas"></canvas>

<div id="controls">
    <button id="riddleBtn" disabled>‚ùì Ask Riddle (-13.5 üçÉ)</button>
</div>

<div id="modal">
    <h2 id="modalTitle" style="color:#A5D6A7;">ü¶• The Ancient Sloth Speaks...</h2>
    <p id="modalText" style="font-size:20px; margin:25px 0;"></p>
    <div id="answerButtons"></div>
    <button id="closeModal" style="margin-top:20px; padding:12px 30px; background:#D32F2F;">Close</button>
</div>

<script type="importmap">
{
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.168.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.168.0/examples/jsm/"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // Global game mode
    let gameMode = null;
    
    // Start game function
    window.startGame = function(mode) {
        gameMode = mode;
        document.getElementById('startScreen').style.display = 'none';
        
        // Show mobile controls and rotate to landscape if mobile mode selected
        if (mode === 'mobile') {
            document.body.classList.add('mobile-mode');
            document.getElementById('mobileControls').style.display = 'block';
            document.getElementById('joystickContainer').style.display = 'block';
        }
        
        // Start the game
        initGame();
    };

    function initGame() {
    const canvas = document.getElementById('gameCanvas');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.FogExp2(0x87CEEB, 0.002);
    
    // Set initial canvas size based on game mode
    if (gameMode === 'mobile') {
        canvas.width = window.innerHeight;
        canvas.height = window.innerWidth;
    }

    // Add clouds to the sky
    const cloudMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffffff, 
        transparent: true, 
        opacity: 0.6 
    });
    for (let i = 0; i < 15; i++) {
        const cloud = new THREE.Mesh(
            new THREE.SphereGeometry(8 + Math.random() * 5, 8, 8),
            cloudMaterial
        );
        cloud.position.set(
            (Math.random() - 0.5) * 200,
            40 + Math.random() * 30,
            (Math.random() - 0.5) * 200
        );
        cloud.scale.x = 1.5 + Math.random();
        scene.add(cloud);
    }

    // Set camera aspect ratio based on game mode
    const aspectRatio = gameMode === 'mobile' 
        ? window.innerHeight / window.innerWidth 
        : window.innerWidth / window.innerHeight;
    
    const camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    
    // Set renderer size based on game mode
    if (gameMode === 'mobile') {
        renderer.setSize(window.innerHeight, window.innerWidth);
    } else {
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;

    // Lighting
    const ambient = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xffffe4, 1.2);
    sun.position.set(30, 60, 40);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    scene.add(sun);

    // Ground with grass texture
    const groundGeometry = new THREE.PlaneGeometry(300, 300);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x4a7c3a,
        roughness: 0.9,
        metalness: 0.1
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Player (red sphere body - visible)
    const playerGeometry = new THREE.SphereGeometry(0.5, 16, 16);
    const playerMaterial = new THREE.MeshStandardMaterial({ 
        color: 0xff0000,
        roughness: 0.7,
        metalness: 0.3,
        emissive: 0x330000,
        emissiveIntensity: 0.3
    });
    const player = new THREE.Mesh(playerGeometry, playerMaterial);
    player.position.y = 0.5;
    player.castShadow = true;
    scene.add(player);
    camera.position.set(0, 4, 8);

    // Create a detailed sloth hanging in the tree
    let sloth = null;
    const slothGroup = new THREE.Group();
    
    const furMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x8B7355, 
        roughness: 0.9,
        metalness: 0.1
    });
    
    // Body (hanging upside down)
    const body = new THREE.Mesh(
        new THREE.SphereGeometry(0.8, 16, 16),
        furMaterial
    );
    body.scale.set(1, 1.3, 0.9);
    body.position.y = 8.5;
    body.castShadow = true;
    slothGroup.add(body);

    // Head (hanging down)
    const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.55, 16, 16),
        furMaterial
    );
    head.position.set(0, 7.5, 0.2);
    head.scale.set(1, 0.9, 1);
    head.castShadow = true;
    slothGroup.add(head);

    // Face patch (lighter color)
    const facePatch = new THREE.Mesh(
        new THREE.CircleGeometry(0.35, 16),
        new THREE.MeshStandardMaterial({ color: 0xD4A574 })
    );
    facePatch.position.set(0, 7.5, 0.55);
    slothGroup.add(facePatch);

    // Eyes
    const eyeGeometry = new THREE.SphereGeometry(0.08, 12, 12);
    const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
    const eyeL = new THREE.Mesh(eyeGeometry, eyeMaterial);
    eyeL.position.set(-0.15, 7.55, 0.52);
    slothGroup.add(eyeL);
    const eyeR = eyeL.clone();
    eyeR.position.x = 0.15;
    slothGroup.add(eyeR);

    // Nose
    const nose = new THREE.Mesh(
        new THREE.SphereGeometry(0.06, 8, 8),
        new THREE.MeshStandardMaterial({ color: 0x000000 })
    );
    nose.position.set(0, 7.4, 0.56);
    slothGroup.add(nose);

    // Arms (hanging up to grip branch)
    const armGeometry = new THREE.CylinderGeometry(0.12, 0.1, 1.2, 12);
    const armL = new THREE.Mesh(armGeometry, furMaterial);
    armL.position.set(-0.5, 9.2, 0);
    armL.rotation.z = -Math.PI / 8;
    armL.castShadow = true;
    slothGroup.add(armL);

    const armR = new THREE.Mesh(armGeometry, furMaterial);
    armR.position.set(0.5, 9.2, 0);
    armR.rotation.z = Math.PI / 8;
    armR.castShadow = true;
    slothGroup.add(armR);

    // Claws/hands
    const clawMaterial = new THREE.MeshStandardMaterial({ color: 0x6B5345 });
    const clawL = new THREE.Mesh(
        new THREE.SphereGeometry(0.15, 8, 8),
        clawMaterial
    );
    clawL.position.set(-0.6, 9.8, 0);
    clawL.scale.set(1, 0.5, 0.7);
    slothGroup.add(clawL);
    const clawR = clawL.clone();
    clawR.position.x = 0.6;
    slothGroup.add(clawR);

    // Legs
    const legGeometry = new THREE.CylinderGeometry(0.12, 0.1, 1, 12);
    const legL = new THREE.Mesh(legGeometry, furMaterial);
    legL.position.set(-0.35, 7.9, 0);
    legL.rotation.z = -Math.PI / 12;
    legL.castShadow = true;
    slothGroup.add(legL);

    const legR = new THREE.Mesh(legGeometry, furMaterial);
    legR.position.set(0.35, 7.9, 0);
    legR.rotation.z = Math.PI / 12;
    legR.castShadow = true;
    slothGroup.add(legR);

    scene.add(slothGroup);
    sloth = slothGroup;
    sloth.position.y = 0;

    // Ground sloth - more realistic, sitting at base of tree
    const groundSlothGroup = new THREE.Group();
    
    const groundFurMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x9B8B7A, 
        roughness: 0.95,
        metalness: 0.05
    });
    
    // Body - sitting position
    const groundBody = new THREE.Mesh(
        new THREE.SphereGeometry(0.9, 20, 20),
        groundFurMaterial
    );
    groundBody.scale.set(1.2, 1.4, 1);
    groundBody.position.set(0, 0.8, 0);
    groundBody.castShadow = true;
    groundSlothGroup.add(groundBody);

    // Head - looking up slightly
    const groundHead = new THREE.Mesh(
        new THREE.SphereGeometry(0.6, 16, 16),
        groundFurMaterial
    );
    groundHead.position.set(0, 1.8, 0.3);
    groundHead.scale.set(0.9, 1, 1.1);
    groundHead.castShadow = true;
    groundSlothGroup.add(groundHead);

    // Snout
    const snout = new THREE.Mesh(
        new THREE.SphereGeometry(0.25, 12, 12),
        new THREE.MeshStandardMaterial({ color: 0xB5A594 })
    );
    snout.position.set(0, 1.75, 0.75);
    snout.scale.set(0.8, 0.7, 1.2);
    groundSlothGroup.add(snout);

    // Eyes
    const groundEyeGeometry = new THREE.SphereGeometry(0.12, 12, 12);
    const groundEyeMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a });
    const groundEyeL = new THREE.Mesh(groundEyeGeometry, groundEyeMaterial);
    groundEyeL.position.set(-0.25, 1.9, 0.65);
    groundSlothGroup.add(groundEyeL);
    const groundEyeR = groundEyeL.clone();
    groundEyeR.position.x = 0.25;
    groundSlothGroup.add(groundEyeR);

    // Eye highlights
    const eyeShine = new THREE.Mesh(
        new THREE.SphereGeometry(0.04, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    eyeShine.position.set(-0.22, 1.95, 0.7);
    groundSlothGroup.add(eyeShine);
    const eyeShine2 = eyeShine.clone();
    eyeShine2.position.x = 0.28;
    groundSlothGroup.add(eyeShine2);

    // Nose
    const groundNose = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 10, 10),
        new THREE.MeshStandardMaterial({ color: 0x000000 })
    );
    groundNose.position.set(0, 1.7, 0.95);
    groundSlothGroup.add(groundNose);

    // Smile
    const smileCurve = new THREE.EllipseCurve(0, 0, 0.15, 0.08, 0, Math.PI, false, 0);
    const smilePoints = smileCurve.getPoints(20);
    const smileGeometry = new THREE.BufferGeometry().setFromPoints(smilePoints);
    const smileLine = new THREE.Line(
        smileGeometry,
        new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 })
    );
    smileLine.position.set(0, 1.62, 0.92);
    smileLine.rotation.x = -Math.PI / 2;
    groundSlothGroup.add(smileLine);

    // Arms - relaxed at sides
    const groundArmGeometry = new THREE.CylinderGeometry(0.15, 0.12, 1.3, 12);
    const groundArmL = new THREE.Mesh(groundArmGeometry, groundFurMaterial);
    groundArmL.position.set(-0.85, 0.9, 0.2);
    groundArmL.rotation.z = Math.PI / 3;
    groundArmL.castShadow = true;
    groundSlothGroup.add(groundArmL);

    const groundArmR = new THREE.Mesh(groundArmGeometry, groundFurMaterial);
    groundArmR.position.set(0.85, 0.9, 0.2);
    groundArmR.rotation.z = -Math.PI / 3;
    groundArmR.castShadow = true;
    groundSlothGroup.add(groundArmR);

    // Claws
    const groundClawMaterial = new THREE.MeshStandardMaterial({ color: 0x4a3f35 });
    const groundClawL = new THREE.Mesh(
        new THREE.SphereGeometry(0.18, 10, 10),
        groundClawMaterial
    );
    groundClawL.position.set(-1.15, 0.35, 0.4);
    groundClawL.scale.set(1.1, 0.6, 0.8);
    groundSlothGroup.add(groundClawL);
    const groundClawR = groundClawL.clone();
    groundClawR.position.x = 1.15;
    groundSlothGroup.add(groundClawR);

    // Legs - sitting
    const groundLegGeometry = new THREE.CylinderGeometry(0.18, 0.16, 0.8, 12);
    const groundLegL = new THREE.Mesh(groundLegGeometry, groundFurMaterial);
    groundLegL.position.set(-0.5, 0.3, 0.3);
    groundLegL.rotation.z = Math.PI / 8;
    groundLegL.castShadow = true;
    groundSlothGroup.add(groundLegL);

    const groundLegR = new THREE.Mesh(groundLegGeometry, groundFurMaterial);
    groundLegR.position.set(0.5, 0.3, 0.3);
    groundLegR.rotation.z = -Math.PI / 8;
    groundLegR.castShadow = true;
    groundSlothGroup.add(groundLegR);

    // Feet
    const groundFootL = new THREE.Mesh(
        new THREE.SphereGeometry(0.22, 10, 10),
        groundClawMaterial
    );
    groundFootL.position.set(-0.65, 0.1, 0.5);
    groundFootL.scale.set(0.9, 0.5, 1.2);
    groundSlothGroup.add(groundFootL);
    const groundFootR = groundFootL.clone();
    groundFootR.position.x = 0.65;
    groundSlothGroup.add(groundFootR);

    // Position ground sloth at base of tree, slightly to the side
    groundSlothGroup.position.set(2.5, 0, -1);
    groundSlothGroup.rotation.y = -Math.PI / 6;
    scene.add(groundSlothGroup);

    // Tree
    const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.8, 1, 10, 12),
        new THREE.MeshStandardMaterial({ color: 0x5D4037, roughness: 1 })
    );
    trunk.position.y = 5;
    trunk.castShadow = true;
    scene.add(trunk);

    // Foliage
    const foliageMat = new THREE.MeshStandardMaterial({
        color: 0x2d5016,
        roughness: 0.8,
        metalness: 0.1
    });
    for (let i = 0; i < 8; i++) {
        const foliage = new THREE.Mesh(
            new THREE.SphereGeometry(4 + Math.random() * 2, 8, 6),
            foliageMat
        );
        foliage.position.set(
            (Math.random() - 0.5) * 4,
            8 + Math.random() * 3,
            (Math.random() - 0.5) * 4
        );
        foliage.castShadow = true;
        foliage.receiveShadow = true;
        scene.add(foliage);
    }

    // Realistic leaves (yellow color)
    const leafMaterial = new THREE.MeshStandardMaterial({
        color: 0xFFEB3B,
        transparent: true,
        side: THREE.DoubleSide,
        opacity: 0.95,
        roughness: 0.8,
        metalness: 0.1,
        emissive: 0xFDD835,
        emissiveIntensity: 0.4
    });

    const leaves = [];
    function createRealisticLeaf(x, z) {
        // Create leaf shape
        const leafShape = new THREE.Shape();
        leafShape.moveTo(0, 0);
        leafShape.quadraticCurveTo(0.4, 0.3, 0.5, 0.6);
        leafShape.quadraticCurveTo(0.3, 0.8, 0, 1);
        leafShape.quadraticCurveTo(-0.3, 0.8, -0.5, 0.6);
        leafShape.quadraticCurveTo(-0.4, 0.3, 0, 0);
        
        const leafGeometry = new THREE.ShapeGeometry(leafShape);
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
        
        leaf.position.set(x, 0.6 + Math.random() * 0.4, z);
        leaf.rotation.set(
            Math.random() * Math.PI * 0.3 - Math.PI * 0.15,
            Math.random() * Math.PI * 2,
            Math.random() * Math.PI * 0.3 - Math.PI * 0.15
        );
        leaf.castShadow = true;
        leaf.userData = { 
            float: Math.random() * Math.PI,
            rotSpeed: (Math.random() - 0.5) * 0.02
        };
        scene.add(leaf);
        leaves.push(leaf);
    }

    // Spawn leaves
    for (let i = 0; i < 30; i++) {
        const angle = Math.random() * Math.PI * 2;
        const dist = 10 + Math.random() * 60;
        createRealisticLeaf(Math.cos(angle) * dist, Math.sin(angle) * dist);
    }

    // Falling leaves effect
    setInterval(() => {
        if (Math.random() < 0.5 && leaves.length < 50) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 20 + Math.random() * 40;
            createRealisticLeaf(
                player.position.x + Math.cos(angle) * dist,
                player.position.z + Math.sin(angle) * dist
            );
        }
    }, 2500);

    // Game state
    let leafCount = 0;
    let totalCollected = 0;
    const leafCountEl = document.getElementById('leafCount');
    const posDisplay = document.getElementById('posDisplay');
    const distDisplay = document.getElementById('distDisplay');
    const riddleBtn = document.getElementById('riddleBtn');

    const riddles = [
        { q: "They're not for playing catch, not for rolling strikes. When frustration peaks and hope retreats, what spheres describe your plight?", a: ["Bouncy Balls","Bowling Balls","Crystal Balls","Blue Balls"], c: 3 },
        { q: "Billie Jean is not my lover, but she dances in moonlight. Who walks backwards while moving forward?", a: ["Michael Jackson","A Moonwalker","The King of Pop","Time Traveler"], c: 2 },
        { q: "A tiger prowls beyond the boundaries, where maps end and legends begin. What beast guards the edge of reality?", a: ["The Guardian Tiger","A Map Error","The Border Beast","meow"], c: 3 },
        { q: "Frogs neither hop nor swim here, yet they croak with wisdom. What amphibian truth lies beneath?", a: ["Ancient Knowledge","Pepe Memes","Frog Philosophy","Hop"], c: 3 },
        { q: "Bread rises not from ovens but from meaning. What sustenance feeds the soul?", a: ["Money/Dough","Bird Bread","Burnt Toast","French Bread"], c: 3 },
        { q: "In the 90s, a man flew without wings, wore 23, and conquered courts. Who defied gravity?", a: ["Michael Jordan","Air Jordan","MJ","The GOAT"], c: 2 },
        { q: "A man of iron with a heart of light. What armor protects the vulnerable within?", a: ["Ego","Pepper","Jar","Pot"], c: 2 },
        { q: "Cards shuffle in Queens NYC, faces hide truths, chips stack like towers. What game mirrors life's bluff?", a: ["Life's Gamble","Poker","Street Games","The Hustle"], c: 1 },
        { q: "The number 254 whispers through dimensions. What code unlocks the hidden realm?", a: ["A Portal Code","ASCII","The Answer","A Secret Number"], c: 1 },
        { q: "Time flows yet stands still. We chase it but can never catch it. What is time but an illusion?", a: ["A Construct","Time Itself","A River","What We Make Of It"], c: 3 },
        { q: "I have keys but cant open doors, and when I breathe, music pours What am I?", a: ["A Piano","A Kazoo","An Accordion","A Broken Flute"], c: 2 },
        { q: "ANGELZ watch from above, neither heaven nor earth. Where do the watchers dwell?", a: ["The Upside Down","The Clouds","Our Hearts","The Shadows"], c: 1 },
        { q: "I am the heaviest of all crowns, yet ninety-one seconds is all it took to make me fall from my throne. Who am I?", a: ["Salman bin Abdulaziz Al Saud","El Rey de los Gansos","King George V","Michael Spinks"], c: 3 },
        { q: "I built a wonder that touched the sky before the great pyramids rose, Physician, sage, and architect‚Äîlater gods would wear my clothes. In mortar, stone, and healing arts the ancients saw my spark, Who am I, deified in time, though mortal at the start?", a: ["Djoser","Imhotep","Ptahhotep","Khufu"], c: 1 },
        { q: "We are tombs that never held the kings they were meant to keep, Older sisters stand as steps, while younger ones cleanly leap. Millions of blocks, a nation's might, aligned to stars above, What are we, the ancient world's most famous monuments of love?", a: ["Ziggurats","Mastabas","Pyramids","Obelisks"], c: 2 },
        { q: "I split between two trucks while the world held its breath, From Monaco's streets I kicked my way to action-movie death. Muscles from Brussels, timeless ham, the 'Frank Dux' of fame, Who am I, the dancing fighter with the nearly unpronounceable name?", a: ["Steven Seagal","Jean-Claude Van Damme","Dolph Lundgren","Chuck Norris"], c: 1 },
        { q: "I am the number of sins a Tibetan mala helps you outrun, The beads you count when seeking peace beneath the rising sun. In the cosmos, Earth and Moon and Sun align with me in play, Stitched in saris, struck in cricket, chanted when you pray. What number am I, sacred from the Himalayas to the stars?", a: ["100","111","108","99"], c: 2 }
    ];

    let currentRiddle = null;
    let askedRiddles = []; // Track which riddles have been asked

    document.getElementById('riddleBtn').onclick = () => {
        if (leafCount >= 13.5) {
            leafCount -= 13.5;
            
            // Get available riddles (not yet asked)
            const availableRiddles = riddles.filter((r, index) => !askedRiddles.includes(index));
            
            // If all riddles have been asked, reset the list
            if (availableRiddles.length === 0) {
                askedRiddles = [];
                availableRiddles.push(...riddles);
            }
            
            // Pick a random riddle from available ones
            const randomIndex = Math.floor(Math.random() * availableRiddles.length);
            currentRiddle = availableRiddles[randomIndex];
            
            // Mark this riddle as asked
            const originalIndex = riddles.indexOf(currentRiddle);
            askedRiddles.push(originalIndex);
            
            showModal("ü¶• Riddle of the Ancients", currentRiddle.q, true, currentRiddle);
            updateUI();
            console.log("Riddle asked! Leaves remaining:", leafCount);
        } else {
            showModal("ü¶• Not Enough Leaves", "The sloth slowly shakes its head... You need at least 13.5 leaves to ask a riddle.", false);
        }
    };

    function showModal(title, text, isRiddle = false, data = null) {
        document.getElementById('modalTitle').textContent = title;
        document.getElementById('modalText').textContent = text;
        const btns = document.getElementById('answerButtons');
        btns.innerHTML = '';
        if (isRiddle) {
            document.getElementById('closeModal').style.display = 'none';
            data.a.forEach((ans, i) => {
                const b = document.createElement('button');
                b.className = 'answer-btn';
                b.textContent = ans;
                b.onclick = () => {
                    if (i === data.c) {
                        leafCount += 6.75;
                        showModal("Correct! üåü", "The sloth nods approvingly. +6.75 leaves!");
                    } else {
                        leafCount = Math.max(0, leafCount - 20);
                        showModal("Wrong...", "The sloth looks disappointed. -20 leaves.");
                    }
                    updateUI();
                };
                btns.appendChild(b);
            });
        } else {
            document.getElementById('closeModal').style.display = 'block';
        }
        document.getElementById('modal').style.display = 'block';
    }

    document.getElementById('closeModal').onclick = () => {
        document.getElementById('modal').style.display = 'none';
    };

    function updateUI() {
        leafCountEl.textContent = leafCount.toFixed(2);
        const enoughForRiddle = leafCount >= 13.5;
        
        riddleBtn.disabled = !enoughForRiddle;
        
        // Visual feedback
        if (enoughForRiddle) {
            riddleBtn.style.opacity = '1';
            riddleBtn.style.cursor = 'pointer';
        } else {
            riddleBtn.style.opacity = '0.5';
            riddleBtn.style.cursor = 'not-allowed';
        }
    }

    // Controls
    const keys = {};
    window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
    window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
    
    let mouseX = 0;
    let targetMouseX = 0;
    
    document.addEventListener('mousemove', e => {
        // Normalize mouse position: -1 (left) to 1 (right)
        targetMouseX = (e.clientX / window.innerWidth) * 2 - 1;
    });

    // Touch swipe for camera rotation (mobile)
    let touchStartX = 0;
    let isSwiping = false;
    
    canvas.addEventListener('touchstart', (e) => {
        // Only track swipes outside the control buttons
        const touch = e.touches[0];
        const controlsElement = document.getElementById('mobileControls');
        if (controlsElement && controlsElement.contains(e.target)) {
            return; // Ignore touches on control buttons
        }
        
        touchStartX = touch.clientX;
        isSwiping = true;
    }, { passive: true });
    
    canvas.addEventListener('touchmove', (e) => {
        if (!isSwiping) return;
        
        const touch = e.touches[0];
        const deltaX = touch.clientX - touchStartX;
        
        // Update camera based on swipe (adjust sensitivity)
        if (gameMode === 'mobile') {
            // For mobile landscape mode, adjust for rotated screen
            targetMouseX += deltaX * 0.003;
        } else {
            targetMouseX += deltaX * 0.002;
        }
        
        // Clamp the value between -1 and 1
        targetMouseX = Math.max(-1, Math.min(1, targetMouseX));
        
        touchStartX = touch.clientX;
    }, { passive: true });
    
    canvas.addEventListener('touchend', () => {
        isSwiping = false;
    }, { passive: true });
    
    canvas.addEventListener('touchcancel', () => {
        isSwiping = false;
    }, { passive: true });

    // Smooth mouse movement
    function updateMousePosition() {
        mouseX += (targetMouseX - mouseX) * 0.1;
    }

    // Mobile controls are shown/hidden based on game mode selection
    // (handled in startGame function)

    // Mobile touch controls
    const touchKeys = { up: false, down: false, left: false, right: false };
    
    const setupTouchButton = (id, key) => {
        const btn = document.getElementById(id);
        if (btn) {
            // Prevent default touch behavior to avoid conflicts
            btn.style.touchAction = 'none';
            btn.style.userSelect = 'none';
            
            // Touch events
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                touchKeys[key] = true;
                btn.classList.add('mobile-btn-active');
            }, { passive: false });
            
            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                touchKeys[key] = false;
                btn.classList.remove('mobile-btn-active');
            }, { passive: false });
            
            btn.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                touchKeys[key] = false;
                btn.classList.remove('mobile-btn-active');
            }, { passive: false });
            
            // Mouse events (for desktop testing)
            btn.addEventListener('mousedown', (e) => {
                e.preventDefault();
                touchKeys[key] = true;
                btn.classList.add('mobile-btn-active');
            });
            
            btn.addEventListener('mouseup', (e) => {
                e.preventDefault();
                touchKeys[key] = false;
                btn.classList.remove('mobile-btn-active');
            });
            
            btn.addEventListener('mouseleave', (e) => {
                touchKeys[key] = false;
                btn.classList.remove('mobile-btn-active');
            });
            
            // Prevent context menu on long press
            btn.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        }
    };

    setupTouchButton('btnUp', 'up');
    setupTouchButton('btnDown', 'down');
    setupTouchButton('btnLeft', 'left');
    setupTouchButton('btnRight', 'right');

    // Joystick controls for camera rotation
    const joystickContainer = document.getElementById('joystickContainer');
    const joystickStick = document.getElementById('joystickStick');
    let joystickActive = false;
    let joystickCenterX = 0;
    let joystickCenterY = 0;
    const joystickRadius = 60; // Base radius
    const stickRadius = 25; // Stick radius
    
    function handleJoystickStart(e) {
        e.preventDefault();
        joystickActive = true;
        const rect = joystickContainer.getBoundingClientRect();
        joystickCenterX = rect.left + rect.width / 2;
        joystickCenterY = rect.top + rect.height / 2;
    }
    
    function handleJoystickMove(e) {
        if (!joystickActive) return;
        e.preventDefault();
        
        const touch = e.touches ? e.touches[0] : e;
        const deltaX = touch.clientX - joystickCenterX;
        const deltaY = touch.clientY - joystickCenterY;
        
        // Calculate distance from center
        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const maxDistance = joystickRadius - stickRadius;
        
        // Constrain stick to base
        let stickX = deltaX;
        let stickY = deltaY;
        
        if (distance > maxDistance) {
            const angle = Math.atan2(deltaY, deltaX);
            stickX = Math.cos(angle) * maxDistance;
            stickY = Math.sin(angle) * maxDistance;
        }
        
        // Update stick position (offset by half stick size to center it)
        joystickStick.style.left = (joystickRadius - stickRadius + stickX) + 'px';
        joystickStick.style.top = (joystickRadius - stickRadius + stickY) + 'px';
        
        // Update camera angle based on X position (-1 to 1)
        const normalizedX = stickX / maxDistance;
        targetMouseX = normalizedX;
    }
    
    function handleJoystickEnd(e) {
        e.preventDefault();
        joystickActive = false;
        
        // Return stick to center with smooth transition
        joystickStick.style.transition = 'all 0.2s ease';
        joystickStick.style.left = '35px';
        joystickStick.style.top = '35px';
        
        setTimeout(() => {
            joystickStick.style.transition = 'none';
        }, 200);
    }
    
    // Touch events for joystick
    joystickContainer.addEventListener('touchstart', handleJoystickStart, { passive: false });
    joystickContainer.addEventListener('touchmove', handleJoystickMove, { passive: false });
    joystickContainer.addEventListener('touchend', handleJoystickEnd, { passive: false });
    joystickContainer.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
    
    // Mouse events for desktop testing
    joystickContainer.addEventListener('mousedown', handleJoystickStart);
    document.addEventListener('mousemove', (e) => {
        if (joystickActive) handleJoystickMove(e);
    });
    document.addEventListener('mouseup', handleJoystickEnd);

    // Animation loop
    let cameraAngle = 0;
    
    function animate() {
        requestAnimationFrame(animate);

        // Update smooth mouse position
        updateMousePosition();

        const speed = 0.18;
        const move = new THREE.Vector3();
        
        // Update camera angle: mouse right = look right (positive angle)
        cameraAngle = -mouseX * Math.PI;
        
        // Keyboard controls: W=forward, S=backward, A=left, D=right (relative to camera)
        if (keys['w']) {
            move.x -= Math.sin(cameraAngle) * speed;
            move.z -= Math.cos(cameraAngle) * speed;
        }
        if (keys['s']) {
            move.x += Math.sin(cameraAngle) * speed;
            move.z += Math.cos(cameraAngle) * speed;
        }
        if (keys['a']) {
            move.x -= Math.cos(cameraAngle) * speed;
            move.z += Math.sin(cameraAngle) * speed;
        }
        if (keys['d']) {
            move.x += Math.cos(cameraAngle) * speed;
            move.z -= Math.sin(cameraAngle) * speed;
        }
        
        // Mobile touch controls: camera-relative directions (same as WASD)
        if (touchKeys.up) {
            move.x -= Math.sin(cameraAngle) * speed;
            move.z -= Math.cos(cameraAngle) * speed;
        }
        if (touchKeys.down) {
            move.x += Math.sin(cameraAngle) * speed;
            move.z += Math.cos(cameraAngle) * speed;
        }
        if (touchKeys.left) {
            move.x -= Math.cos(cameraAngle) * speed;
            move.z += Math.sin(cameraAngle) * speed;
        }
        if (touchKeys.right) {
            move.x += Math.cos(cameraAngle) * speed;
            move.z -= Math.sin(cameraAngle) * speed;
        }
        
        player.position.add(move);

        // Floating & rotating leaves
        leaves.forEach((leaf, i) => {
            leaf.rotation.y += leaf.userData.rotSpeed;
            leaf.rotation.z += 0.005;
            leaf.position.y += Math.sin(Date.now() * 0.001 + leaf.userData.float) * 0.004;

            const distance = player.position.distanceTo(leaf.position);
            if (distance < 1.2) {
                scene.remove(leaf);
                leaves.splice(i, 1);
                leafCount += 0.5;  // Each leaf is worth 0.5
                totalCollected += 1;
                updateUI();

                // Particle effect on collection
                for (let j = 0; j < 5; j++) {
                    const particle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.05),
                        new THREE.MeshBasicMaterial({ color: 0xFFEB3B })
                    );
                    particle.position.copy(leaf.position);
                    particle.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.1,
                        Math.random() * 0.15,
                        (Math.random() - 0.5) * 0.1
                    );
                    scene.add(particle);
                    setTimeout(() => scene.remove(particle), 500);
                }

                // Occasionally spawn more far away
                if (Math.random() < 0.4 && leaves.length < 50) {
                    const angle = Math.random() * Math.PI * 2;
                    const dist = 30 + Math.random() * 50;
                    createRealisticLeaf(
                        player.position.x + Math.cos(angle) * dist, 
                        player.position.z + Math.sin(angle) * dist
                    );
                }
            }
        });

        // Update stats display
        posDisplay.textContent = `${Math.round(player.position.x)}, ${Math.round(player.position.z)}`;
        const distToSloth = Math.sqrt(player.position.x ** 2 + player.position.z ** 2);
        distDisplay.textContent = Math.round(distToSloth);

        // Gentle sloth animation (tree sloth)
        if (sloth) {
            sloth.position.y = Math.sin(Date.now() * 0.0005) * 0.15;
            sloth.rotation.y = Math.sin(Date.now() * 0.0003) * 0.1;
        }

        // Animate ground sloth - subtle breathing and blinking
        if (groundSlothGroup) {
            // Gentle breathing
            groundSlothGroup.children[0].scale.y = 1.4 + Math.sin(Date.now() * 0.001) * 0.05;
            // Slight head movement
            groundSlothGroup.children[1].rotation.y = Math.sin(Date.now() * 0.0004) * 0.15;
            groundSlothGroup.children[1].rotation.x = Math.sin(Date.now() * 0.0003) * 0.1;
        }

        // Third-person camera following player
        const idealOffset = new THREE.Vector3(
            Math.sin(cameraAngle) * 9,
            5,
            Math.cos(cameraAngle) * 9
        );
        camera.position.lerp(player.position.clone().add(idealOffset), 0.1);
        camera.lookAt(player.position.x, player.position.y + 1.5, player.position.z);

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        // Adjust for mobile landscape mode
        if (gameMode === 'mobile') {
            camera.aspect = window.innerHeight / window.innerWidth;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerHeight, window.innerWidth);
        } else {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    });

    updateUI();
    animate();
    } // End of initGame function
</script>
</body>
</html>
